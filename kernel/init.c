/*
 * Copyright (C) 2023 GreenWaves Technologies, ETH Zurich and University of Bologna
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/*
 * Authors: Germain Haugou (germain.haugou@gmail.com)
 */

#include <stdlib.h>
#include <stdint.h>
#include <kernel/init.h>
#include <kernel/link.h>
#include <kernel/hal.h>
#include <lib/libc/minimal/libc.h>


// Function type for constructors / desctructors
typedef void (*__ctor_dtor_ptr_t)(void);

// COnstructors generated by the compiler. They are stored in a dedicated section
static __ctor_dtor_ptr_t ctor_list[1] __attribute__((section(".ctors.start"))) =
    { (__ctor_dtor_ptr_t) - 1 };

// Destructors generated by the compiler. They are stored in a dedicated section
static __ctor_dtor_ptr_t dtor_list[1] __attribute__((section(".dtors.start"))) =
    { (__ctor_dtor_ptr_t) - 1 };

// External main function brought by user code and called by our init function
extern int main();


// Call all constructors one by one
static void __pi_init_do_ctors(void)
{
    __ctor_dtor_ptr_t *fpp;

    for(fpp = ctor_list+1;  *fpp != 0;  ++fpp)
    {
        (**fpp)();
    }
}


// Call all destructors one by one
static void __pi_init_do_dtors(void)
{
    __ctor_dtor_ptr_t *fpp;
    for(fpp = dtor_list + 1;  *fpp != 0;  ++fpp)
    {
        (**fpp)();
    }
}



static __attribute__((noinline)) void __pi_init_bss()
{
    unsigned int *bss = (unsigned int *)__pi_init_bss_start();
    unsigned int *bss_end = (unsigned int *)__pi_init_bss_end();

    // INIT_INF("BSS init (start: 0x%x, end: 0x%x)\n", bss, bss_end);

    while (bss != bss_end)
    {
        *bss++ = 0;
    }
}



void __pi_init_start()
{
    // BSS init
    __pi_init_bss();

#ifdef CONFIG_LIBC
    // Early libc initialization to have printf ready as soon as possible.
    // This will make it available only for simple devices like semi-hosting, not for uart.
    __pi_libc_init();
#endif

    // Call global and static constructors
    // Each module may do private initializations there
    __pi_init_do_ctors();

#ifdef CONFIG_LIBC
    // Now that the system is ready, activate more complex IO like uart
    __pi_libc_start();
#endif

    int retval = main();

    // Propagate retval to the loader
    __pi_init_stop(retval);

    return;

error:
    __pi_init_stop(-1);
}



void __pi_init_stop(int status)
{
#ifdef CONFIG_LIBC
    // Close IO to flush them
    __pi_libc_stop();
#endif

    // Call global and static destructors
    __pi_init_do_dtors();

    // Stop the platform
    __pi_init_platform_exit(status);
}
